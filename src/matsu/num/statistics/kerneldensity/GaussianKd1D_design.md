# GaussianKd1D の設計

`matsu.num.statistics.kerneldensity.GaussianKd1D` の設計を考えるためのドキュメントである.


## カーネル密度推定と離散化
カーネル密度推定 (以下, KDE) は, 連続な横軸に対して定義されるが, コンピュータで扱うためには離散化される.
この離散化の空間分解能は, カーネルの幅よりも細かい部分についてはあまり意味がない.
したがって, カーネルの幅スケールの定数倍を離散化の単位として設計するのが良い.

カーネルの幅を基準に離散化した場合を考える.
KDE のためのフィルタ関数は, 離散化した配列上ではカーネルの幅に依らず固定となる.
KDE は, データソースをこれに合わせて離散化し, 離散化したフィルタを適用すればよい.
これは, ナイーブに次のような処理となる.

1. カーネルの幅スケールを基準に横軸を離散化する.
2. データ点を, 離散化された座標点に重みづけで配分する.
    例えば, 離散化した座標が `(0, 1, 2, ...)` であるとしてデータ点が `1.2` である場合は,
    座標 `1` に 4/5 を, 座標 `2` に 1/5 を割り振る.
    全てのデータ点について座標に対して割り振りを行い, 全空間で規格化することで, 各座標点での重み (配列) を得る.
3. 重み配列に対してフィルタを適用し, 結果を得る.
    これは離散畳み込み演算である.
    フィルタサイズが有限であるので, 端を適当にゼロ埋めすれば問題ない.

データ数が少ない場合は重み配列の生成と畳み込みはコストが増えるが,
現実上は「データ数が多い場合の効率的な KDE」を実現すれば, データ数が少ない場合も問題ない.


## 計算するメッシュの範囲
横軸の範囲は, データ点の分布に対して横軸が十分に狭い場合,
その横軸に合わせて離散化 (し, 端を拡張) すればよい.
反対に, 横軸の範囲がデータ点の分布に対して十分に広い場合,
横軸に合わせて離散化した場合は端の方は重みが 0 埋めされるので無駄が多い.
したがって, 入力された範囲に合わせて, 不要な端をカットして計算すればよい.

ナイーブには, データ点の最小値と最大値を基準とし, それとの大小で分岐すればよい.
ただ, この場合は次のような問題も含んでいることに注意する.


## 極端な値への対応
データ点に極端な値を持つ場合, 離散化の分解能に対して対応するメッシュ数が多くなりがちである.
したがって, メッシュの細かさをカーネルの幅スケールのみに依存させるのは危険である.
そこで, 次のような2個の基準で考え, 粗い方のメッシュを採用するというのが現実的であろう.

- データ点の分布から計算されたカーネルの幅スケールに基づくメッシュ
- 計算範囲と分割数に基づくメッシュ

すなわち, 分割数の上限を定めておくようにするのである.
おそらくは, 分割数は大きめに取るようにしておき,
標準的な範囲でのKDEでは前者のメッシュが採用されるようにするのが良いだろう.
